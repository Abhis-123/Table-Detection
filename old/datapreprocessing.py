# -*- coding: utf-8 -*-
"""datapreprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/175TyiebKm1lMWt9HeAErntO_b0qx_fuw
"""

import sys
#from common_func import *
#from data_structure import *
import os
import cv2
import shutil
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import xmltodict
import xml.etree.ElementTree as ET
from matplotlib.patches import Rectangle 
import logger
#from google.colab import drive
#drive.mount('/content/drive')

path='drive/MyDrive/hackthon/data/images/00017.PNG'
image=cv2.imread(path)
#gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
#plt.imshow(gray)
#plt.title('my picture')
#plt.figsize(200,400)
#plt.show()
#image.shape
#gray.shape

"""# New section"""
path='data/images/00001.PNG'
image=cv2.imread(path)
#gray = cv2.cvtColor(image,cv2.)
#cv2.imshow('image',image)
cv2.rectangle(image,(1050,25),(200,150),(0,0,0),2)  
cv2.imshow('image',image) 
cv2.waitKey(0) 
cv2.destroyAllWindows()  
#plt.imshow(image)
#plt.show()

im=cv2.imread(path)
plt.imshow(im)

im.shape

xml_data = open('data/labels/00001.xml', 'r').read()  # Read file
root = ET.XML(xml_data)

data = []
cols = []
for i, child in enumerate(root):
    data.append([subchild.text for subchild in child])
    cols.append(child.tag)

df = pd.DataFrame(data).T  # Write in DF and transpose it
df.columns = cols  # Update column names
print(df)

print(enumerate(root))

xmlDict=xmltodict.parse(xml_data)

cols = xmlDict['annotation'].keys()

xmlDict['annotation']['object']

def sanitize_coord(coordinates, width, height):
    """
    points are: [[xmin, ymin], [xmax, ymin], [xmin, ymax], [xmax, ymax]]
    it sanitize the coordinates that are extracted from a xml file. Valid for this dataset,
    to be updated in case the dataset changes
    Returning as dict: xmin, ymin, xmax, ymax
    :param coordinates:[[xmin, ymin], [xmax, ymin], [xmin, ymax], [xmax, ymax]]
    :return: dict with xmin, ymin, xmax, ymax coordinates
    """
    coordinates = coordinates.split()
    points = []
    for point in coordinates:
        point = point.split(',')
        points.append(point)
    new_points = {
        'xmin': points[0][0],
        'ymin': points[0][1],
        'xmax': points[3][0],
        'ymax': points[3][1]
    }
    # logger.info(new_points)
    # logger.info('width: {w}, height: {h}'.format(w=width, h=height))
    # check if coords are inverted
    if int(new_points['ymin']) > int(new_points['ymax']):
        logger.info('I found you y!')
        temp = int(new_points['ymin'])
        new_points['ymin'] = int(new_points['ymax'])
        new_points['ymax'] = temp
    if int(new_points['xmin']) > int(new_points['xmax']):
        logger.info('I found you x!')
        temp = new_points['xmin']
        new_points['xmin'] = int(new_points['xmax'])
        new_points['xmax'] = temp
    if int(new_points['ymin']) < 0:
        logger.info('Found some ymin at zero:')
        new_points['ymin'] = 0
    if int(new_points['xmin']) < 0:
        logger.info('Found some xmin at zero')
        new_points['xmin'] = 0
    if int(new_points['ymax']) > height:
        logger.info('Found some ymax beyond height: \nwidth: {w}, height: {h}\nnew_point["ymax"]: {npyx}' \
                    .format(w=width, h=height, npyx=new_points['ymax']))
        new_points['ymax'] = height
    if int(new_points['xmax']) > width:
        logger.info('Found some xmax beyond height: \nwidth: {w}, height: {h}\nnew_point["xmax"]: {npxx}' \
                    .format(w=width, h=height, npxx=new_points['xmax']))
        new_points['xmax'] = width

    if (int(new_points['xmax']) - int(new_points['xmin'])) < MIN_WIDTH_BOX or \
            (int(new_points['ymax']) - int(new_points['ymin'])) < MIN_HEIGHT_BOX:
        logger.info('Box {} was too small. Going to delete it'.format(new_points))
        new_points = None
    return new_points

xmlDict

# return dictionary of all values
# requirement pandas , xml.etree.ElementTree as ET and 

def read_xml(path):
    # Read file 
    xml_data=open(path).read()
    # return dictionary of the file
    xmlDict=xmltodict.parse(xml_data)
    return xmlDict

def getFileList(path):
    ret = []
    for rt,dirs,files in os.walk(path):
         for filename in files:
            ret.append(filename)

# dict={xmin:values,}
def drawrect_cv(image,list,rect_color=(0,0,0),rect_width=2):
    for dict in list:
        xmin=dict['xmin']
        ymin=dict['ymin']
        xmax=dict['xmax']
        ymax=dict['ymax']
        rect_color=(0,0,0) 
        rect_width=2
        cv2.rectangle(image,
                      (int(xmin),int(ymax)),
                      (int(xmax),int(ymin)),
                      rect_color,
                      rect_width)  
    cv2.imshow('image',image) 
    cv2.waitKey(0)    
    #cv2.destroyWindow()
def drawrect_plt(img,list,rect_color=(0,0,0),rect_width=2):
    from matplotlib.patches import Rectangle
    plt.imshow(img)
    for dict in list:
        
        xmin=int(dict['xmin'])
        ymin=int(dict['ymin'])
        xmax=int(dict['xmax'])
        ymax=int(dict['ymax'])
        #plt.imshow(img[:,:,0])
        #plt.imshow(img[:,:,1])
        ax = plt.gca()
        rect = Rectangle((xmin,ymin),
                     (xmax-xmin),
                     (ymax-ymin),
                     linewidth=1,
                     edgecolor='r',
                     facecolor='none')
        ax.add_patch(rect)

image=cv2.imread('data/images/00001.PNG')
xml_data=read_xml('data/labels/00001.xml')
drawrect_cv(image,xml_data['annotation']['object']['bndbox'],rect_color=(200,100,0))

drawrect_plt(image,xml_data['annotation']['object']['bndbox'],rect_color=(200,100,0))

import os
folderpath = 'data/images'
files = os.listdir(folderpath)
files

import string
df=pd.DataFrame(files,columns=['filename'])
df['filepath']='data/images/'+df['filename']
df['targetfilepath']='data/labels/'+df['filename'].apply(lambda x:x.replace('PNG','xml'))

read_xml(df['targetfilepath'][5])['annotation']['object']['bndbox']

def getimagedimention(xmlpath):
    xmldata=read_xml(xmlpath)
    dimention=xmldata['annotation']['size']
    return list((dimention['width'],dimention['height'],dimention['depth']))

df['imagesize']=df['targetfilepath'].apply(getimagedimention)

def getbndboxdimention(xmlpath):
    xmldata=read_xml(xmlpath)
    l=[]
    o=xmldata['annotation']['object']
    dimention=o
    if isinstance(o,type(l)):
        return dimention
    else:
        l.append(dimention)
        return l

def gettablecount(xmlpath):
    xmldata=read_xml(xmlpath)
    l=[]
    o=xmldata['annotation']['object']
    if isinstance(o,type(l)):
        return len(o)
    else:
        return 1
    
read_xml(df['targetfilepath'][2])
df['tablecount']=df['targetfilepath'].apply(gettablecount)
df['tables']=df['targetfilepath'].apply(getbndboxdimention)

def getlimits(listoftables):
    limits=[]
    for x in listoftables:
        limits.append(x['bndbox'])
    return limits
        
getlimits(df.iloc[2]['tables'])

df['bndboxlim']=df['tables'].apply(getlimits)
df.head(3)

path=df.iloc[1]['filepath']
bndboxlim=df.iloc[1]['bndboxlim']
image=cv2.imread(path)
drawrect_plt(image,bndboxlim)

df.to_csv('datatesttrain/records.csv')

path=df.iloc[1]['filepath']
bndboxlim=df.iloc[1]['bndboxlim']
image=cv2.imread(path)
image=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)
drawrect_cv(image,bndboxlim)

